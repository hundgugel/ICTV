<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR –ü–ª–∞–Ω—ñ–º–µ—Ç—Ä—ñ—è - –í–Ω—É—Ç—Ä—è–Ω–∫–∞</title>
    <script src="../aframe/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        
        #modeSelector {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .mode-btn {
            margin: 5px;
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        .mode-btn.active {
            background: #FF6B35;
        }
        
        #infoPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .calculation {
            margin: 10px 0;
            padding: 8px;
            background: rgba(76, 175, 80, 0.2);
            border-left: 3px solid #4CAF50;
        }
    </style>
</head>
<body>
    <!-- –°–µ–ª–µ–∫—Ç–æ—Ä —Ä–µ–∂–∏–º—ñ–≤ -->
    <div id="modeSelector">
        <h4>üîß –†–µ–∂–∏–º —Ä–æ–±–æ—Ç–∏:</h4>
        <button class="mode-btn active" onclick="setMode('triangle')">–¢—Ä–∏–∫—É—Ç–Ω–∏–∫ (3 —Ç–æ—á–∫–∏)</button>
        <button class="mode-btn" onclick="setMode('quadrilateral')">–ß–µ—Ç—ã—Ä–µ—Ö–∫—É—Ç–Ω–∏–∫ (4 —Ç–æ—á–∫–∏)</button>
        <button class="mode-btn" onclick="setMode('pentagon')">–ü'—è—Ç–∏–∫—É—Ç–Ω–∏–∫ (5 —Ç–æ—á–æ–∫)</button>
    </div>

    <!-- –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ–π–Ω–∞ –ø–∞–Ω–µ–ª—å -->
    <div id="infoPanel">
        <h4 id="infoTitle">–ì–æ—Ç–æ–≤–æ –¥–æ —Ä–æ–±–æ—Ç–∏</h4>
        <div id="calculations"></div>
    </div>

    <!-- AR –°—Ü–µ–Ω–∞ -->
    <a-scene 
        vr-mode-ui="enabled: false" 
        arjs="sourceType: webcam; debugUIEnabled: false;"
        renderer="logarithmicDepthBuffer: true;"
        embedded
        style="width: 100%; height: 100%">

        <!-- –°–¢–ê–¢–ò–ß–ù–Ü –ú–ê–†–ö–ï–†–ò –ó –§–û–†–ú–£–õ–ê–ú–ò -->
        
        <!-- –ú–∞—Ä–∫–µ—Ä 1: –¢—Ä–∏–∫—É—Ç–Ω–∏–∫ –∑ —Ñ–æ—Ä–º—É–ª–∞–º–∏ -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-tr.patt" id="triangleMarker">
            <!-- –¢—Ä–∏–≤–∏–º—ñ—Ä–Ω–∏–π —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫ -->
            <a-entity id="triangleFormulas" geometry="primitive: plane; width: 3; height: 2" 
                     material="color: rgba(255,255,255,0.9); transparent: true" 
                     position="0 0 0.1" 
                     text="value: –¢–†–ò–ö–£–¢–ù–ò–ö\n\n–ü–ª–æ—â–∞: S = (1/2) √ó a √ó h\n–ü–ª–æ—â–∞ –ì–µ—Ä–æ–Ω–∞: S = ‚àö[p(p-a)(p-b)(p-c)]\n–ü–µ—Ä–∏–º–µ—Ç—Ä: P = a + b + c\n–¢–µ–æ—Ä–µ–º–∞ –ü—ñ—Ñ–∞–≥–æ—Ä–∞: a¬≤ + b¬≤ = c¬≤; 
                           color: black; align: center; width: 8">
                <!-- –ê–Ω—ñ–º–æ–≤–∞–Ω–∏–π 3D —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫ -->
                <a-triangle position="0 1.5 0" rotation="0 0 0" scale="0.8 0.8 0.8" 
                           material="color: #FF6B35; transparent: true; opacity: 0.7"
                           animation="property: rotation; to: 0 360 0; loop: true; dur: 8000">
                </a-triangle>
            </a-entity>
        </a-marker>

        <!-- –ú–∞—Ä–∫–µ—Ä 2: –ö–≤–∞–¥—Ä–∞—Ç –∑ —Ñ–æ—Ä–º—É–ª–∞–º–∏ -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-sq.patt" id="squareMarker">
            <a-entity id="squareFormulas" geometry="primitive: plane; width: 3; height: 2" 
                     material="color: rgba(255,255,255,0.9); transparent: true" 
                     position="0 0 0.1" 
                     text="value: –ß–û–¢–ò–†–ò–ö–£–¢–ù–ò–ö–ò\n\n–ö–≤–∞–¥—Ä–∞—Ç: S = a¬≤\n–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫: S = a √ó b\n–†–æ–º–±: S = (1/2) √ó d‚ÇÅ √ó d‚ÇÇ\n–ü–∞—Ä–∞–ª–µ–ª–æ–≥—Ä–∞–º: S = a √ó h\n–¢—Ä–∞–ø–µ—Ü—ñ—è: S = (1/2)(a+b) √ó h; 
                           color: black; align: center; width: 8">
                <!-- –ê–Ω—ñ–º–æ–≤–∞–Ω–∏–π –∫—É–± -->
                <a-box position="0 1.5 0" rotation="45 45 0" scale="0.6 0.6 0.6" 
                       material="color: #4ECDC4; transparent: true; opacity: 0.8"
                       animation="property: rotation; to: 405 405 360; loop: true; dur: 10000">
                </a-box>
            </a-entity>
        </a-marker>

        <!-- –ú–∞—Ä–∫–µ—Ä 3: N - –ú–Ω–æ–≥–æ–∫—É—Ç–Ω–∏–∫–∏ -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-n.patt" id="nMarker">
            <a-entity id="polygonFormulas" geometry="primitive: plane; width: 3; height: 2" 
                     material="color: rgba(255,255,255,0.9); transparent: true" 
                     position="0 0 0.1" 
                     text="value: N-–ö–£–¢–ù–ò–ö–ò\n\n–ü—Ä–∞–≤–∏–ª—å–Ω–∏–π n-–∫—É—Ç–Ω–∏–∫:\nS = (1/4)n √ó a¬≤ √ó ctg(œÄ/n)\n–°—É–º–∞ –∫—É—Ç—ñ–≤: (n-2) √ó 180¬∞\n–í–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π –∫—É—Ç: (n-2) √ó 180¬∞/n\n–ó–æ–≤–Ω—ñ—à–Ω—ñ–π –∫—É—Ç: 360¬∞/n; 
                           color: black; align: center; width: 8">
                <!-- –ê–Ω—ñ–º–æ–≤–∞–Ω–∏–π –æ–∫—Ç–∞–µ–¥—Ä -->
                <a-octahedron position="0 1.5 0" rotation="0 0 0" scale="0.7 0.7 0.7" 
                             material="color: #9B59B6; transparent: true; opacity: 0.7"
                             animation="property: rotation; to: 360 360 360; loop: true; dur: 12000">
                </a-octahedron>
            </a-entity>
        </a-marker>

        <!-- –î–ò–ù–ê–ú–Ü–ß–ù–Ü –¢–û–ß–ö–û–í–Ü –ú–ê–†–ö–ï–†–ò (A, B, C, D, G, F) -->
        
        <!-- –¢–æ—á–∫–∞ A -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterA.patt" id="pointA">
            <a-sphere id="sphereA" position="0 0.5 0" radius="0.1" material="color: #FF6B35; metalness: 0.8">
                <a-text value="A" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –¢–æ—á–∫–∞ B -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterB.patt" id="pointB">
            <a-sphere id="sphereB" position="0 0.5 0" radius="0.1" material="color: #4ECDC4; metalness: 0.8">
                <a-text value="B" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –¢–æ—á–∫–∞ C -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterC.patt" id="pointC">
            <a-sphere id="sphereC" position="0 0.5 0" radius="0.1" material="color: #45B7D1; metalness: 0.8">
                <a-text value="C" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –¢–æ—á–∫–∞ D -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterD.patt" id="pointD">
            <a-sphere id="sphereD" position="0 0.5 0" radius="0.1" material="color: #96CEB4; metalness: 0.8">
                <a-text value="D" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –¢–æ—á–∫–∞ G -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterG.patt" id="pointG">
            <a-sphere id="sphereG" position="0 0.5 0" radius="0.1" material="color: #FFEAA7; metalness: 0.8">
                <a-text value="G" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –¢–æ—á–∫–∞ F -->
        <a-marker preset="custom" type="pattern" url="../markers/pattern-letterF.patt" id="pointF">
            <a-sphere id="sphereF" position="0 0.5 0" radius="0.1" material="color: #DDA0DD; metalness: 0.8">
                <a-text value="F" position="0 0.3 0" align="center" color="white" scale="2 2 2"></a-text>
            </a-sphere>
        </a-marker>

        <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ª—ñ–Ω—ñ–π -->
        <a-entity id="linesContainer"></a-entity>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // === –ì–ï–û–ú–ï–¢–†–ò–ß–ù–Ü –†–û–ó–†–ê–•–£–ù–ö–ò ===
        
        class GeometryCalculator {
            // –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –¥–≤–æ–º–∞ —Ç–æ—á–∫–∞–º–∏
            static distance(p1, p2) {
                return Math.sqrt(
                    Math.pow(p2.x - p1.x, 2) + 
                    Math.pow(p2.y - p1.y, 2) + 
                    Math.pow(p2.z - p1.z, 2)
                );
            }
            
            // –ö—É—Ç –º—ñ–∂ —Ç—Ä—å–æ–º–∞ —Ç–æ—á–∫–∞–º–∏ (B - –≤–µ—Ä—à–∏–Ω–∞ –∫—É—Ç–∞)
            static angle(p1, p2, p3) {
                const a = this.distance(p2, p3);
                const b = this.distance(p1, p3);
                const c = this.distance(p1, p2);
                
                const cosAngle = (a*a + c*c - b*b) / (2*a*c);
                return Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
            }
            
            // –ü–ª–æ—â–∞ —Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∞ –∑–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
            static triangleArea(p1, p2, p3) {
                const a = this.distance(p1, p2);
                const b = this.distance(p2, p3);
                const c = this.distance(p3, p1);
                const s = (a + b + c) / 2;
                return Math.sqrt(s * (s - a) * (s - b) * (s - c));
            }
            
            // –ü–ª–æ—â–∞ –º–Ω–æ–≥–æ–∫—É—Ç–Ω–∏–∫–∞ (–º–µ—Ç–æ–¥ —Ç—Ä–∞–ø–µ—Ü—ñ–π)
            static polygonArea(points) {
                let area = 0;
                const n = points.length;
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += points[i].x * points[j].z - points[j].x * points[i].z;
                }
                return Math.abs(area) / 2;
            }
        }

        // === –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–Ü–ù–ù–Ø –†–ï–ñ–ò–ú–ê–ú–ò ===
        
        let currentMode = 'triangle';
        let detectedPoints = {};
        let activeLines = [];

        function setMode(mode) {
            currentMode = mode;
            
            // –û–Ω–æ–≤–ª—é—î–º–æ UI
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // –û—á–∏—â—É—î–º–æ —Å—Ç–∞—Ä—ñ –ª—ñ–Ω—ñ—ó
            clearLines();
            
            // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
            updateInfo();
        }

        // === –°–ò–°–¢–ï–ú–ê –í–Ü–î–°–õ–Ü–î–ö–û–í–£–í–ê–ù–ù–Ø –ú–ê–†–ö–ï–†–Ü–í ===
        
        function initializeMarkerTracking() {
            const pointMarkers = ['pointA', 'pointB', 'pointC', 'pointD', 'pointG', 'pointF'];
            
            pointMarkers.forEach(markerId => {
                const marker = document.querySelector(`#${markerId}`);
                if (marker) {
                    marker.addEventListener('markerFound', () => {
                        detectedPoints[markerId] = marker;
                        updateGeometry();
                    });
                    
                    marker.addEventListener('markerLost', () => {
                        delete detectedPoints[markerId];
                        updateGeometry();
                    });
                }
            });
        }

        // === –ì–ï–û–ú–ï–¢–†–ò–ß–ù–Ü –†–û–ó–†–ê–•–£–ù–ö–ò –¢–ê –í–Ü–ó–£–ê–õ–Ü–ó–ê–¶–Ü–Ø ===
        
        function updateGeometry() {
            const requiredPoints = getRequiredPoints();
            const availablePoints = Object.keys(detectedPoints);
            
            if (availablePoints.length >= requiredPoints.length) {
                const activePoints = requiredPoints.map(pointId => detectedPoints[pointId]).filter(p => p);
                
                if (activePoints.length === requiredPoints.length) {
                    drawLines(activePoints);
                    calculateProperties(activePoints);
                }
            } else {
                clearLines();
                updateInfo('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ç–æ—á–æ–∫ –¥–ª—è ' + getModeLabel());
            }
        }

        function getRequiredPoints() {
            switch (currentMode) {
                case 'triangle': return ['pointA', 'pointB', 'pointC'];
                case 'quadrilateral': return ['pointA', 'pointB', 'pointC', 'pointD'];
                case 'pentagon': return ['pointA', 'pointB', 'pointC', 'pointD', 'pointG'];
                default: return [];
            }
        }

        function getModeLabel() {
            switch (currentMode) {
                case 'triangle': return '—Ç—Ä–∏–∫—É—Ç–Ω–∏–∫–∞';
                case 'quadrilateral': return '—á–µ—Ç—ã—Ä–µ—Ö–∫—É—Ç–Ω–∏–∫–∞';
                case 'pentagon': return "–ø'—è—Ç–∏–∫—É—Ç–Ω–∏–∫–∞";
                default: return '—Ñ—ñ–≥—É—Ä–∏';
            }
        }

        // === –í–Ü–î–ú–ê–õ–Æ–í–ê–ù–ù–Ø –õ–Ü–ù–Ü–ô ===
        
        function drawLines(points) {
            clearLines();
            const container = document.querySelector('#linesContainer');
            
            for (let i = 0; i < points.length; i++) {
                const start = points[i];
                const end = points[(i + 1) % points.length];
                
                const line = createLine(
                    start.object3D.position,
                    end.object3D.position
                );
                
                container.appendChild(line);
                activeLines.push(line);
            }
        }

        function createLine(start, end) {
            const line = document.createElement('a-entity');
            
            // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–∑–∏—Ü—ñ—ó —Ç–∞ —Ä–æ—Ç–∞—Ü—ñ—ó –ª—ñ–Ω—ñ—ó
            const distance = GeometryCalculator.distance(start, end);
            const midpoint = {
                x: (start.x + end.x) / 2,
                y: (start.y + end.y) / 2,
                z: (start.z + end.z) / 2
            };
            
            const direction = {
                x: end.x - start.x,
                y: end.y - start.y,
                z: end.z - start.z
            };
            
            const rotationY = Math.atan2(direction.x, direction.z) * 180 / Math.PI;
            const rotationX = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z)) * 180 / Math.PI;
            
            line.setAttribute('geometry', `primitive: cylinder; radius: 0.02; height: ${distance}`);
            line.setAttribute('material', 'color: #FF6B35; metalness: 0.8');
            line.setAttribute('position', `${midpoint.x} ${midpoint.y} ${midpoint.z}`);
            line.setAttribute('rotation', `${-rotationX} ${rotationY} 0`);
            
            return line;
        }

        function clearLines() {
            activeLines.forEach(line => line.remove());
            activeLines = [];
        }

        // === –†–û–ó–†–ê–•–£–ù–û–ö –í–õ–ê–°–¢–ò–í–û–°–¢–ï–ô ===
        
        function calculateProperties(markers) {
            const points = markers.map(marker => marker.object3D.position);
            let calculations = '';
            
            if (currentMode === 'triangle' && points.length === 3) {
                const sides = [
                    GeometryCalculator.distance(points[0], points[1]),
                    GeometryCalculator.distance(points[1], points[2]),
                    GeometryCalculator.distance(points[2], points[0])
                ];
                
                const angles = [
                    GeometryCalculator.angle(points[2], points[0], points[1]),
                    GeometryCalculator.angle(points[0], points[1], points[2]),
                    GeometryCalculator.angle(points[1], points[2], points[0])
                ];
                
                const area = GeometryCalculator.triangleArea(points[0], points[1], points[2]);
                const perimeter = sides.reduce((sum, side) => sum + side, 0);
                
                calculations = `
                    <div class="calculation">
                        <strong>–°—Ç–æ—Ä–æ–Ω–∏:</strong><br>
                        AB = ${sides[0].toFixed(2)}<br>
                        BC = ${sides[1].toFixed(2)}<br>
                        CA = ${sides[2].toFixed(2)}
                    </div>
                    <div class="calculation">
                        <strong>–ö—É—Ç–∏:</strong><br>
                        ‚à†A = ${angles[0].toFixed(1)}¬∞<br>
                        ‚à†B = ${angles[1].toFixed(1)}¬∞<br>
                        ‚à†C = ${angles[2].toFixed(1)}¬∞
                    </div>
                    <div class="calculation">
                        <strong>–ü–ª–æ—â–∞:</strong> ${area.toFixed(2)}<br>
                        <strong>–ü–µ—Ä–∏–º–µ—Ç—Ä:</strong> ${perimeter.toFixed(2)}
                    </div>
                `;
            } else if (points.length >= 4) {
                const area = GeometryCalculator.polygonArea(points);
                let perimeter = 0;
                
                for (let i = 0; i < points.length; i++) {
                    const next = (i + 1) % points.length;
                    perimeter += GeometryCalculator.distance(points[i], points[next]);
                }
                
                calculations = `
                    <div class="calculation">
                        <strong>–ü–ª–æ—â–∞:</strong> ${area.toFixed(2)}<br>
                        <strong>–ü–µ—Ä–∏–º–µ—Ç—Ä:</strong> ${perimeter.toFixed(2)}<br>
                        <strong>–ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–µ—Ä—à–∏–Ω:</strong> ${points.length}
                    </div>
                `;
            }
            
            updateInfo(`${getModeLabel().charAt(0).toUpperCase() + getModeLabel().slice(1)} –ø–æ–±—É–¥–æ–≤–∞–Ω–æ!`, calculations);
        }

        // === –û–ù–û–í–õ–ï–ù–ù–Ø –Ü–ù–¢–ï–†–§–ï–ô–°–£ ===
        
        function updateInfo(title = '–ì–æ—Ç–æ–≤–æ –¥–æ —Ä–æ–±–æ—Ç–∏', calculations = '') {
            document.getElementById('infoTitle').textContent = title;
            document.getElementById('calculations').innerHTML = calculations;
        }

        // === –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø ===
        
        document.addEventListener('DOMContentLoaded', () => {
            // –ß–µ–∫–∞—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è A-Frame
            document.querySelector('a-scene').addEventListener('loaded', () => {
                setTimeout(() => {
                    initializeMarkerTracking();
                    updateInfo();
                }, 1000);
            });
        });

        // === –ö–û–ú–ü–û–ù–ï–ù–¢ –¢–†–ò–ö–£–¢–ù–ò–ö–ê ===
        
        AFRAME.registerGeometry('triangle', {
            schema: {
                vertices: {default: '0 1 0, -1 -1 0, 1 -1 0'}
            },
            
            init: function(data) {
                const vertices = data.vertices.split(',').map(v => {
                    const coords = v.trim().split(' ').map(Number);
                    return new THREE.Vector3(coords[0], coords[1], coords[2]);
                });
                
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(vertices.length * 3);
                
                vertices.forEach((vertex, i) => {
                    positions[i * 3] = vertex.x;
                    positions[i * 3 + 1] = vertex.y;
                    positions[i * 3 + 2] = vertex.z;
                });
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setIndex([0, 1, 2]);
                geometry.computeVertexNormals();
                
                this.geometry = geometry;
            }
        });
    </script>
</body>
</html>